# ADR-0006: スマート壁スライディングの実装

## ステータス

**承認済み** (2025-12-20)

## コンテキスト

ADR-0005でray_dda.cのバグを修正した後、プレイヤー移動の新たな問題が発見された：

### 問題1: 壁に垂直に当たったときの挙動

既存の壁スライディング実装では：
```c
// 既存の実装（修正前）
if (!is_wall(game, new_x, new_y)) {
    // 両軸移動
} else {
    // 壁に当たった場合、各軸を個別に試す
    if (!is_wall(game, new_x, old_y))
        game->player.pos_x = new_x;
    if (!is_wall(game, old_x, new_y))
        game->player.pos_y = new_y;
}
```

**症状**:
- プレイヤーが壁にほぼ垂直に当たっても、微小な成分の方向にスライドする
- 例: 移動方向(-0.66, -0.02) = X:97%, Y:3%の場合
  - X方向がブロックされても、Y方向（3%）にスライドし続ける
  - 「壁に当たったのに止まらない」という違和感

### 問題2: 後方への移動

壁スライディング中に、前進方向とは逆方向に移動する現象：

**症状**:
```
[W] pos(5.64,1.21) → X増加（前進）
[D] pos(5.64,1.21) → X減少（後退！）
```

- Dキー（右ストレーフ）を押すと、前進の逆方向に移動
- plane(-0.04,-0.66)で、Y成分（94%）がブロックされ、X成分（6%）だけ動く
- しかしX方向が前進とは逆向き → 「後退している」と感じる

## 検討した選択肢

### 選択肢 1: 壁スライディングを完全に無効化（不採用）

**メリット**:
- シンプル
- 壁に当たったら必ず停止

**デメリット**:
- FPSゲームの標準的な操作感に反する
- 斜めに壁に当たっても停止してしまう
- プレイ体験が悪化

### 選択肢 2: 閾値ベースのスマート壁スライディング（採用）

**メリット**:
- 垂直な衝突では停止、斜めの衝突ではスライド
- 自然な操作感
- プレイヤーの意図に沿った挙動

**デメリット**:
- 実装がやや複雑
- 閾値の調整が必要

### 選択肢 3: 物理エンジンベースの壁スライディング（不採用）

**メリット**:
- 物理的に正確
- 壁の法線ベクトルを使用

**デメリット**:
- オーバーエンジニアリング
- 42 Normの関数行数制限に抵触する可能性
- パフォーマンスコスト

## 決定

**選択肢 2を採用**: 閾値ベースのスマート壁スライディングと後方移動防止を実装する。

### 実装方針

#### 1. 閾値ベースの挙動判定

移動ベクトルの各軸の割合を計算し、主要軸を判定：

```c
dx = abs(movement_x);
dy = abs(movement_y);
total = dx + dy;

if (dy / total >= 0.8) {
    // Y軸が主要（80%以上）
    // Y方向のみ試す、ブロックされたら停止
} else if (dx / total >= 0.8) {
    // X軸が主要（80%以上）
    // X方向のみ試す、ブロックされたら停止
} else {
    // 斜め移動（両方 < 80%）
    // 従来通りスライディング許可（後方移動チェック付き）
}
```

**閾値 80%の根拠**:
- 90度 ÷ 2 = 45度が境界
- cos(45°) ≈ 0.707
- 余裕を見て80%に設定
- ユーザーテストで調整可能

#### 2. 後方移動の防止

スライディング時に、移動方向が前進方向（dir）と逆向きでないかチェック：

```c
// 内積を使用した方向チェック
if (!is_wall(game, new_x, game->player.pos_y)
    && (new_x - game->player.pos_x) * game->player.dir_x >= 0) {
    // X方向のスライドが前進方向と同じ向き、または垂直
    game->player.pos_x = new_x;
}
```

**内積の意味**:
- 正の値: 同じ向き、または垂直（許可）
- 負の値: 逆向き（拒否）

### 実装詳細

**ファイル**: `srcs/engine/player/player_movement.c`

**変更対象関数**:
- `move_forward()` - 前進
- `move_backward()` - 後退
- `move_left()` - 左ストレーフ
- `move_right()` - 右ストレーフ

**新しい変数**:
```c
double dx;      // X軸移動量の絶対値
double dy;      // Y軸移動量の絶対値
double total;   // 合計移動量
```

**実装例（move_forward）**:
```c
void move_forward(t_game *game)
{
    double new_x, new_y, dx, dy, total;

    new_x = game->player.pos_x + game->player.dir_x * MOVE_SPEED;
    new_y = game->player.pos_y + game->player.dir_y * MOVE_SPEED;

    // 両軸移動を試す
    if (!is_wall(game, new_x, new_y)) {
        game->player.pos_x = new_x;
        game->player.pos_y = new_y;
        return;
    }

    // 各軸の割合を計算
    dx = game->player.dir_x * MOVE_SPEED;
    dy = game->player.dir_y * MOVE_SPEED;
    if (dx < 0) dx = -dx;
    if (dy < 0) dy = -dy;
    total = dx + dy;

    // Y軸が主要（≥80%）
    if (dy / total >= 0.8 && !is_wall(game, game->player.pos_x, new_y))
        game->player.pos_y = new_y;
    // X軸が主要（≥80%）
    else if (dx / total >= 0.8 && !is_wall(game, new_x, game->player.pos_y))
        game->player.pos_x = new_x;
    // 斜め移動（両方 < 80%）- スライディング許可
    else if (dy / total < 0.8 && dx / total < 0.8) {
        // X方向スライド（後方移動チェック付き）
        if (!is_wall(game, new_x, game->player.pos_y)
            && (new_x - game->player.pos_x) * game->player.dir_x >= 0)
            game->player.pos_x = new_x;
        // Y方向スライド（後方移動チェック付き）
        else if (!is_wall(game, game->player.pos_x, new_y)
            && (new_y - game->player.pos_y) * game->player.dir_y >= 0)
            game->player.pos_y = new_y;
    }
}
```

## 結果

### 正の影響

1. **自然な壁衝突**:
   - 垂直に壁に当たる → 停止
   - 斜めに壁に当たる → 壁沿いにスライド
   - プレイヤーの期待通りの挙動

2. **後方移動の防止**:
   - ストレーフキー（A/D）で後退しない
   - 前進の進行方向を維持
   - 操作の直感性が向上

3. **42 Norm準拠**:
   - 各関数25行以内
   - 変数宣言は関数の先頭
   - ネストレベル適切

### 負の影響

1. **関数の複雑化**:
   - 各移動関数が長くなった（20-25行程度）
   - ただし25行制限内に収まっている

2. **パフォーマンス**:
   - 除算と乗算が増加
   - ただし毎フレーム4関数（最大）のみなので影響は軽微

3. **調整の必要性**:
   - 閾値80%が最適かはユーザーテストで確認が必要
   - 必要に応じて調整可能（定数化を検討）

### テスト結果

**テストケース1**: 垂直な壁衝突
```
移動: plane(-0.04,-0.66) = X:6%, Y:94%
結果: Y方向ブロック → 停止（Xにスライドしない）✓
```

**テストケース2**: 斜めの壁衝突
```
移動: dir(0.88,-0.47) = X:65%, Y:35%
結果: Y方向ブロック → X方向にスライド ✓
```

**テストケース3**: 後方移動の防止
```
前進: X増加
ストレーフ: X減少を試みる → 内積チェックで拒否 ✓
```

## 関連決定

- [ADR-0003: プレイヤー移動・回転の実装方針](./0003-player-movement-implementation.md)
  - 基本的な移動ロジックを定義
  - 今回はその拡張
- [ADR-0005: world_map配列インデックスの修正](./0005-fix-world-map-array-indexing.md)
  - この修正により正しいマップが読まれるようになった
  - 壁スライディングが正しく機能するようになった

## 参照

- [player モジュール設計](../design/modules/engine/player/design.md)
- [raycasting モジュール設計](../design/modules/engine/raycasting/design.md)

## メモ

### 実装後の改善履歴

- **2025-12-20**: 初期実装
  - 閾値80%で実装
  - 4つの移動関数に適用
  - ユーザーテストで良好な結果

### 将来の拡張可能性

1. **閾値の定数化**:
   ```c
   #define WALL_SLIDE_THRESHOLD 0.8
   ```
   - 設定ファイルで変更可能にする

2. **壁の法線ベクトル使用** (将来):
   - より物理的に正確なスライディング
   - パフォーマンスとのトレードオフ

3. **スライディング速度の調整**:
   - 壁沿いは少し遅くする
   - よりリアルな操作感

### ユーザーフィードバック

- **肯定的**: 「動きがよくなりました」
- **肯定的**: 「後退しなくなった」
- **肯定的**: 「垂直に当たると止まる」

### 教訓

1. **ユーザーテストの重要性**:
   - 閾値の調整はユーザーの感覚が重要
   - ログ出力で動作を確認しながら調整

2. **段階的な改善**:
   - まず閾値ベース実装
   - 次に後方移動防止追加
   - 小さく確実に改善

3. **内積の有用性**:
   - ベクトルの向きチェックに内積は有効
   - シンプルで効率的

### デバッグログの活用

実装中、以下のデバッグログが有用だった：
```c
printf("[D] pos(%.2f,%.2f) plane(%.2f,%.2f) new(%.2f,%.2f)\n",
    game->player.pos_x, game->player.pos_y,
    game->player.plane_x, game->player.plane_y,
    new_x, new_y);
```

これにより：
- 移動方向の確認
- スライディングの発生確認
- 後方移動の検出

が可能になった。提出前に削除予定。
